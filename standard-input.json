{
  "language": "Solidity",
  "sources": {
    "contracts/task1/BinarySearch.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/// @title BinarySearch\n/// @notice 在有序数组上进行二分查找；若不存在返回 -1。\n///         另外提供 lowerBound（第一个 >= target 的位置，可能等于 length）。\ncontract BinarySearch {\n    /// -------------------- int256 版本 --------------------\n\n    /// @dev 标准二分：命中返回下标，否则 -1。\n    function binarySearchInt(int256[] memory a, int256 target) public pure returns (int256) {\n        if (a.length == 0) return -1;\n\n        uint256 l = 0;\n        uint256 r = a.length - 1;\n\n        while (l <= r) {\n            uint256 mid = l + (r - l) / 2; // 防溢出的取中法\n            int256 v = a[mid];\n\n            if (v == target) return int256(mid);\n            if (v < target) {\n                l = mid + 1;\n            } else {\n                if (mid == 0) break; // 防止 r = mid - 1 下溢\n                r = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    /// @dev lowerBound：返回第一个 >= target 的位置（可能等于 a.length）\n    function lowerBoundInt(int256[] memory a, int256 target) public pure returns (uint256) {\n        uint256 l = 0;\n        uint256 r = a.length; // 采用半开区间 [l, r)\n\n        while (l < r) {\n            uint256 mid = l + (r - l) / 2;\n            if (a[mid] < target) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        return l;\n    }\n\n    /// -------------------- uint256 版本 --------------------\n\n    function binarySearchUint(uint256[] memory a, uint256 target) public pure returns (int256) {\n        if (a.length == 0) return -1;\n\n        uint256 l = 0;\n        uint256 r = a.length - 1;\n\n        while (l <= r) {\n            uint256 mid = l + (r - l) / 2;\n            uint256 v = a[mid];\n\n            if (v == target) return int256(mid);\n            if (v < target) {\n                l = mid + 1;\n            } else {\n                if (mid == 0) break; // 防下溢\n                r = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    function lowerBoundUint(uint256[] memory a, uint256 target) public pure returns (uint256) {\n        uint256 l = 0;\n        uint256 r = a.length;\n\n        while (l < r) {\n            uint256 mid = l + (r - l) / 2;\n            if (a[mid] < target) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        return l;\n    }\n}\n"
    },
    "contracts/task1/IntegerToRoman.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract IntegerToRoman {\n    \n    /// @notice 将 1..3999 的十进制整数转换为罗马数字\n    function intToRoman(uint256 num) public pure returns (string memory) {\n        require(num >= 1 && num <= 3999, \"out of range (1..3999)\");\n\n        // 贪心表（从大到小），与 LeetCode 同顺序：\n        // 1000(M), 900(CM), 500(D), 400(CD), 100(C), 90(XC), 50(L), 40(XL), 10(X), 9(IX), 5(V), 4(IV), 1(I)\n        uint16[13] memory values = [\n            uint16(1000), 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        ];\n        string[13] memory symbols = [\n            \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\n        ];\n\n        // 逐项贪心拼接\n        bytes memory out = bytes(\"\");\n        for (uint256 i = 0; i < values.length; i++) {\n            while (num >= values[i]) {\n                // 追加当前符号，并扣减数值\n                out = bytes.concat(out, bytes(symbols[i]));\n                num -= values[i];\n            }\n            if (num == 0) break;\n        }\n        return string(out);\n    }\n}\n"
    },
    "contracts/task1/MergeSortedArray.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract MergeSortedArray {\n    /// @notice 合并两个已升序排序的 int256 数组，返回升序新数组\n    function mergeSortedInt(int256[] memory a, int256[] memory b) public pure returns (int256[] memory) {\n        uint256 n = a.length;\n        uint256 m = b.length;\n        int256[] memory res = new int256[](n + m);\n\n        uint256 i; // a 的指针\n        uint256 j; // b 的指针\n        uint256 k; // res 的写入指针\n\n        // 双指针归并\n        while (i < n && j < m) {\n            if (a[i] <= b[j]) {\n                res[k++] = a[i++];\n            } else {\n                res[k++] = b[j++];\n            }\n        }\n\n        // 追加剩余\n        while (i < n) res[k++] = a[i++];\n        while (j < m) res[k++] = b[j++];\n\n        return res;\n    }\n\n    /// @notice 合并两个已升序排序的 uint256 数组，返回升序新数组\n    function mergeSortedUint(uint256[] memory a, uint256[] memory b) public pure returns (uint256[] memory) {\n        uint256 n = a.length;\n        uint256 m = b.length;\n        uint256[] memory res = new uint256[](n + m);\n\n        uint256 i; // a 的指针\n        uint256 j; // b 的指针\n        uint256 k; // res 的写入指针\n\n        while (i < n && j < m) {\n            if (a[i] <= b[j]) {\n                res[k++] = a[i++];\n            } else {\n                res[k++] = b[j++];\n            }\n        }\n        while (i < n) res[k++] = a[i++];\n        while (j < m) res[k++] = b[j++];\n\n        return res;\n    }\n}\n"
    },
    "contracts/task1/RomanToInteger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract RomanToInteger {\n\n    /*\n    总结一句话\n    这段代码用“前后对比”的经典法则实现了罗马数字到整数的转换：\n    前小后大 → 减；否则 → 加，循环处理“上一个字符”，最后再把最后一个加上即可。\n    */\n    // pure 既不读也不改合约状态；只能用参数、局部变量、常量做计算。\n    function romanToInt(string memory s) public pure returns (uint256) { // XIV\n        bytes memory bs = bytes(s);\n        require(bs.length > 0, \"empty\");\n\n        int256 sum;\n        int256 pre = getValue(bs[0]); // 10\n\n        for (uint256 i = 1; i < bs.length; i++) {\n\n            // cur = I = 1 \n            // cur = V = 5\n            int256 cur = getValue(bs[i]); \n\n            if (pre < cur) {\n                sum -= pre;\n            } else {\n                sum += pre;\n            }\n\n            pre = cur;\n        }\n\n        int256 r = sum + pre;\n\n        require(r >= 0, \"invalid numeral\"); // 理论上不会负，保险起见\n        return uint256(r);\n    }\n\n    // 没有 switch，用 if/else；用 ASCII 十六进制（更稳）\n    function getValue(bytes1 c) internal pure returns (int256) {\n        if (c == 0x49) return 1; // 'I'\n        if (c == 0x56) return 5; // 'V'\n        if (c == 0x58) return 10; // 'X'\n        if (c == 0x4C) return 50; // 'L'\n        if (c == 0x43) return 100; // 'C'\n        if (c == 0x44) return 500; // 'D'\n        if (c == 0x4D) return 1000; // 'M'\n        return 0;\n    }\n}\n"
    },
    "contracts/task1/StringReverser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract StringReverser {\n    /// @notice 反转 ASCII 字符串（按字节反转；\"abcde\" -> \"edcba\"）\n    /// @dev 适用于英文/数字等单字节字符；多字节 UTF-8 会乱码\n    function reverseAscii(string memory s) public pure returns (string memory) {\n        bytes memory b = bytes(s);\n        uint256 n = b.length;\n        if (n == 0) return \"\";\n\n        bytes memory out = new bytes(n);\n        for (uint256 i = 0; i < n; i++) {\n            out[i] = b[n - 1 - i];\n        }\n\n        return string(out);\n    }\n\n    // 左右指针\n    function reverseString(string memory s) public pure returns (string memory) {\n        bytes memory b = bytes(s);\n        uint256 n = b.length;\n        if (n == 0) return s;\n\n        uint256 left = 0;\n        uint256 right = n - 1;\n\n        while (left < right) {\n            bytes1 tmp = b[left];\n            b[left] = b[right];\n            b[right] = tmp;\n            unchecked {\n                left++;\n                right--;\n            } // 有 while 条件保护，可用 unchecked 微省 gas\n        }\n        return string(b);\n    }\n}\n"
    },
    "contracts/task1/Voting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/*\n✅ 创建一个名为Voting的合约，包含以下功能：\n一个mapping来存储候选人的得票数\n一个vote函数，允许用户投票给某个候选人\n一个getVotes函数，返回某个候选人的得票数\n一个resetVotes函数，重置所有候选人的得票数\n */\n\n/// @title Voting - 简单投票合约（含重置&候选人列表）\n/// @notice 用 string 作为候选人ID，演示 data location 与重载写法\ncontract Voting {\n    // 候选人 -> 票数\n    mapping(string => uint256) private _votes;\n\n    // 是否已收录，用于给 _candidates 去重\n    mapping(string => bool) private _seen;\n    \n    // 可遍历的候选人列表（用于 reset / 前端展示）\n    string[] private _candidates;\n\n    address public owner;\n\n    // 这是事件声明（不是函数），用于把发生的关键动作写进链上日志（供前端/索引服务监听）。\n    event Voted(address indexed voter, string candidate, uint256 newCount);\n    // indexed 让你可以按投票人/操作者地址做筛选查询。\n    event VotesReset(address indexed by);\n\n    modifier onlyOwner() {\n        // 只有“当前直接调用者”是 owner 才能继续\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    /// @param initialCandidates 部署时可选的初始候选人（memory）\n    constructor(string[] memory initialCandidates) {\n        owner = msg.sender;\n        for (uint256 i = 0; i < initialCandidates.length; i++) {\n            // 这里是 memory 实参，走 memory 版本的重载\n            _addCandidateIfNew(initialCandidates[i]);\n        }\n    }\n\n    /// @notice 给候选人投一票；如首次出现会自动加入候选人列表\n    function vote(string calldata candidate) external {\n        // 这里是 calldata 实参，走 calldata 版本的重载（零拷贝到这里）\n        _addCandidateIfNew(candidate);\n        uint256 newCount = ++_votes[candidate];\n        emit Voted(msg.sender, candidate, newCount); // 写一条投票日志（事件）\n    }\n\n    /// @notice 查询某候选人的得票\n    function getVotes(string calldata candidate) external view returns (uint256) {\n        return _votes[candidate];\n    }\n\n    /*\n    @notice 重置所有候选人的票数为 0（仅 owner）\n    onlyOwner 修饰器先检查 msg.sender == owner（不是 owner 会 revert）。\n    最后 emit VotesReset(...) 记一条“有人清空了计票”的事件日志，便于审计/前端刷新。\n     */ \n    function resetVotes() external onlyOwner {\n        for (uint256 i = 0; i < _candidates.length; i++) {\n            _votes[_candidates[i]] = 0;\n        }\n        emit VotesReset(msg.sender);\n    }\n\n    /// @notice  列出当前所有候选人 （可选）\n    function listCandidates() external view returns (string[] memory) {\n        return _candidates;\n    }\n\n    // ---------- 内部工具（重载：calldata / memory 各一份） ----------\n    function _addCandidateIfNew(string memory candidate) internal {\n        if (!_seen[candidate]) {\n            _seen[candidate] = true;\n            _candidates.push(candidate); // 从 memory 拷贝到 storage\n        }\n    }\n}\n"
    },
    "contracts/task2/SimpleERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/// @title SimpleERC20 - 教学用最小实现（参考 IERC20）\n/// @notice 仅合约 owner 可增发\ncontract SimpleERC20 {\n    // ---- 元数据 ----\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n\n    // ---- ERC20 状态  总发行量----\n    uint256 public totalSupply;\n\n    // Solidity 会自动生成同名的 getter 函数\n    mapping(address => uint256) public balanceOf; // 用户地址的余额。\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    // ---- Ownable ---- 简单的所有者地址，用来限制 mint 权限。\n    address public owner;\n\n    // onlyOwner 用于保护 增发 和 换 owner 等敏感操作。\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: not owner\");\n        _;\n    }\n\n    // ---- 事件（与 ERC20 标准一致）---- 对外可观察的“日志”\n    // 标准要求：转账必须 emit Transfer(from, to, amount)；\n    // 授权必须 emit Approval(owner, spender, amount)。\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    // 构造时初始化元数据与 owner。\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals; // 一般为 18\n        owner = msg.sender;\n    }\n\n    // ---- 基础转账 ----\n    function transfer(address to, uint256 amount) external returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    // ---- 授权 ----\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // ---- 代扣转账 ----\n    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n        require(allowed >= amount, \"ERC20: insufficient allowance\");\n\n        _transfer(from, to, amount);\n\n        // 允许“无限授权”不扣减\n        if (allowed != type(uint256).max) {\n            allowance[from][msg.sender] = allowed - amount;\n            emit Approval(from, msg.sender, allowance[from][msg.sender]);\n        }\n\n        return true;\n    }\n\n    // ---- 仅 owner 可增发 ----\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n\n    // ---- 可选：转移所有权 ----\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"zero addr\");\n        owner = newOwner;\n    }\n\n    // ---- 内部逻辑 ----\n    function _transfer(address from, address to, uint256 amount) internal {\n        require(to != address(0), \"ERC20: to zero\");\n\n        uint256 fromBal = balanceOf[from];\n        require(fromBal >= amount, \"ERC20: insufficient balance\");\n\n        unchecked {\n            balanceOf[from] = fromBal - amount;\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }\n\n    function _mint(address to, uint256 amount) internal {\n        require(to != address(0), \"ERC20: mint to zero\");\n        totalSupply += amount;\n        balanceOf[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}
